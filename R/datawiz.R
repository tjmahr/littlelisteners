
#' Read eyetracking data from a datawiz file
#'
#' @param filename a txt file generated by datawiz
#' @param sampling_rate the rate of the video recording in ms. By default, the
#'   value is 33.3 for 1 frame every 33.3 ms.
#' @return a dataframe containing the cleaned-up eyetracking data
#' @export
#' @details
#' The files exported by DataWiz are a series of tab-separated data files all
#' combined into a single file. This means that the header row (with the column
#' names separated by tabs) will be repeated throughout the file. These repeated
#' header rows are removed.
#'
#' The header rows indicate the time of eyetracking samples by columns named
#' "F0", "F33", "F67", etc. There are also columns with blank names before
#' column "F0". These are also looking samples before "F0". This function
#' back-fills the column names so that the first column before "F0" changes from
#' " " to "X33", where the X indicates a negative time sample.
read_datawiz <- function(filename, sampling_rate = 33.3333) {
  # Datawiz files are tab-separated files containing several tables concatenated
  # together, so there are multiple rows with the column names. I have also
  # run into completely empty lines too. Some of the rows
  # may be "ragged". For example, in the 2nd row here, there are more columns of
  # data than there are columns in the header row. Finally, there are blank
  # column names. These are negative time frames (before F0).

  # Header1	Header2	Header3	 	 	 	 	 	F0	F33	F67
  # KidA	Day1	Data3	-	-	-	-	-	-	-	-
  # KidA	Day1	Data3	.	.	.	.	.	.	.	. . . .
  # KidA	Day1	Data3	0	0	0	0	0	0	0	0
  #
  # Header1	Header2	Header3	 	 	 	 	 	F0	F33	F67
  # KidA	Day2	Data3	1	1	1	1	1	1	1	1
  # KidA	Day2	Data3	.	-	0	1	.	-	0	1
  # KidA	Day2	Data3	1	1	1	0	0	.	.	.
  # Header1	Header2	Header3	 	 	 	 	 	F0	F33	F67
  # KidB	Day1	Data3	.	.	.	.	.	.	.	.
  # KidB	Day1	Data3	.	.	.	.	.	.	.	.
  # KidB	Day1	Data3	.	.	.	.	.	.	.	.


  # Handle the empty line problem at read time
  lines <- readr::read_lines(filename, skip_empty_rows = TRUE)

  # Handle the repeated header line problem
  first_few_col_names <- lines[1] |>
    stringr::str_split("\t") |>
    unlist() |>
    utils::head() |>
    paste0(collapse = "\t")

  re_header <- paste0("^", first_few_col_names)

  lines_clean <- c(
    lines[1],
    lines[-1] |>
      stringr::str_subset(re_header, negate = TRUE)
  )

  # Handle the ragged row problem by reading into long format and pivoting into
  # wide format
  m <- meltr::melt_tsv(I(lines_clean))

  # Prepare columns names of wide dataframe

  # Get the known column names
  header <- rep(NA, max(m$col))
  header_in_file <- m |>
    dplyr::filter(.data$row == 1) |>
    dplyr::pull(.data$value)
  header[seq_along(header_in_file)] <- header_in_file

  # Impute blank column names before F0 as negative (prefix with X)
  f0_col <- m |>
    dplyr::filter(.data$value == "F0", .data$row == 1) |>
    dplyr::pull(.data$col)

  blanks_before_f0 <- header[seq_len(f0_col)] |> is.na() |> which()

  header <- header |>
    fill_column_names_in_range(
      range_start = min(blanks_before_f0),
      range_end = max(blanks_before_f0),
      col_prefix = "X",
      increment = 33.3333333,
      direction = "backward"
    ) |>
    # Renumber all positive times (cols from F33 and after, prefix with F)
    fill_column_names_in_range(
      range_start = which(header == "F33"),
      # range_end = max(blanks_before_f0),
      col_prefix = "F",
      increment = 33.3333333,
      direction = "forward"
    )

  m |>
    dplyr::left_join(
      tibble::tibble(col_name = header, col = seq_along(header)),
      by = "col"
    ) |>
    dplyr::filter(.data$row != 1) |>
    tidyr::pivot_wider(
      id_cols = dplyr::one_of("row"),
      names_from = "col_name",
      values_from = "value"
    ) |>
    dplyr::select(-dplyr::one_of("row"))
}




fill_column_names_in_range <- function(
    cols,
    range_start,
    range_end = NULL,
    col_prefix,
    increment,
    offset = 0,
    rounding = 0,
    direction = c("forward", "backward")
) {
  direction <- match.arg(direction)
  range_end <- range_end %||% length(cols)

  new_cols <- column_sequence(
    seq(range_start, range_end),
    col_prefix,
    increment,
    offset,
    rounding,
    direction
  )
  cols[seq(range_start, range_end)] <- new_cols
  cols
}


column_sequence <- function(
    cols,
    col_prefix,
    increment,
    offset = 0,
    rounding = 0,
    direction = c("forward", "backward")
) {
  direction <- match.arg(direction)
  times <- (seq_along(cols) * increment) + offset
  time_values <- round(times, rounding)
  col_names <- sprintf("%s%s", col_prefix, time_values)

  if (direction == "forward") {
    col_names
  } else {
    rev(col_names)
  }
}


#' Convert DataWiz data into long format
#'
#' DataWiz files have several columns F0, F33, F67, etc. for each time sample.
#' This function converts a dataframe from such a file into a long format, where
#' there is a single time column and single column of gaze responses.
#'
#' @param df a dataframe created by reading a datawiz file
#' @param key_col the name of the new column that holds the time values
#' @param value_col the name of the new column that holds the looking data at
#'   each time sample
#' @return a long data-frame
#' @export
melt_datawiz <- function(df, key_col = "Time", value_col = "Look") {
  # Assuming X[Numbers] and F[Numbers] are the time columns
  time_cols <- stringr::str_subset(colnames(df), "^[XF]\\d+$")

  df |>
    tidyr::gather_(key_col = key_col, value_col = value_col,
                   gather_cols = time_cols, na.rm = FALSE, convert = FALSE,
                   factor_key = FALSE) |>
    mutate_(Time = ~ as_time(Time))
}

as_time <- function(xs) {
  xs |>
    stringr::str_replace("^X", "-") |>
    stringr::str_replace("^F", "+") |>
    as.numeric()
}


#' Convert to DataWiz codes to AOI names
#'
#' @param xs a vector of DataWiz codes (-, ., 0, 1)
#' @return the vector with NA for "-", "Target" for "1", "Distractor" for "0", and
#'   "tracked" for ".".
#' @export
convert_datawiz_code_to_aoi <- function(xs) {
  xs <- xs |>
    stringr::str_replace("[-]", "NA") |>
    stringr::str_replace("1", "Target") |>
    stringr::str_replace("0", "Distractor") |>
    stringr::str_replace("[.]", "tracked")
  xs[xs == "NA"] <- NA
  xs
}

as_word <- function(xs) {
  xs <- xs |>
    stringr::str_replace("[-]", "dash") |>
    stringr::str_replace("1", "Target") |>
    stringr::str_replace("0", "Distractor") |>
    stringr::str_replace("[.]", "dot")
  xs[xs == "NA"] <- NA
  xs
}

